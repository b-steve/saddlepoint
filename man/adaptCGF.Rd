% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/D-AdaptCGF.R
\name{adaptCGF}
\alias{adaptCGF}
\title{Create an adapted CGF object using an adaptor function}
\usage{
adaptCGF(cgf, param_adaptor, ...)
}
\arguments{
\item{cgf}{A \code{CGF} object to be adapted.}

\item{param_adaptor}{An \code{adaptor} or a function with signature \code{function(theta) -> adapted_param}.}

\item{...}{Additional named arguments passed to \code{\link{createCGF}}, the \code{CGF} object creation function (rarely needed).}
}
\value{
A new \code{CGF} object.
}
\description{
Constructs a new \code{CGF} object by adapting the parameter vector using a user-supplied
\code{param_adaptor} before invoking the original \code{CGF}'s methods.
}
\details{
This function is useful when you have a \code{CGF} that expects its parameter vector
to be in a certain format, but your high-level model provides a different parameter
structure. By specifying a \code{param_adaptor}, you can dynamically
translate your model parameters to those that \code{cgf} requires.
}
\examples{
\dontrun{
## Example: Suppose you have a sum of two Poisson r.v.s, each with
##   a different lambda, but your model uses a single parameter 'theta'
##   from which the two lambdas are derived (lambda1 = theta, lambda2 = 2*theta).

## Scenario:
## Y1 ~ Poisson(theta)
## Y2 ~ Poisson(2*theta)
## Y = Y1 + Y2 ~ Poisson(3*theta)
## Model Parameters: theta
## CGF for Y expects: distribution_params = c(lambda1, lambda2) = c(theta, 2*theta)


# First, the individual Poisson CGFs with separate lambda parameters
# These will expect a vector of length 2 for the two lambdas
K_Y1 <- PoissonModelCGF(lambda = adaptor(indices = 1))   # For Y1: lambda1 => the first parameter
K_Y2 <- PoissonModelCGF(lambda = adaptor(indices = 2))   # For Y2: lambda2 => the second parameter

# sum_cgf is a CGF that expects 2 parameters for the two Poisson variables
sum_cgf <- sumOfIndependentCGF(cgf_list = list(K_Y1, K_Y2))

# param_adaptor that converts 'theta' to c(lambda1, lambda2)
mapThetaToDistParams <- function(theta) c(theta, 2*theta) 

# Now adapt sum_cgf so it only needs a single 'theta':
adapted_cgf <- adaptCGF(cgf = sum_cgf, param_adaptor = mapThetaToDistParams)
theta0 <- 5
adapted_cgf$K1(0, theta0)  
# OR sum_cgf$K1(0, c(theta0, 2*theta0))
# OR PoissonCGF$K1(0, 3*theta0)
}

}
