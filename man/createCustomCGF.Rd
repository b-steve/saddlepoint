% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cgf_from_rfunctions.R
\name{createCustomCGF}
\alias{createCustomCGF}
\title{Create an additional CGF object.}
\usage{
createCustomCGF(
  Kvectorized,
  K1vectorized,
  K2vectorized,
  K3vectorized = NULL,
  K4vectorized = NULL,
  ineq_vectorized = NULL
)
}
\arguments{
\item{Kvectorized}{A function representing the vectorized version of K.}

\item{K1vectorized}{A function representing the vectorized version of K1 (first derivative of K).}

\item{K2vectorized}{A function representing the vectorized version of K2 (second derivative of K).}

\item{K3vectorized}{A function representing the vectorized third derivative of K, essential for discrepancy calculations. If omitted, it defaults to returning a zero vector the length of tvec. Without an implementation of \code{K3vectorized} function, discrepancy calculations should not be performed.}

\item{K4vectorized}{A function representing the vectorized fourth derivative of K. If omitted, it defaults to returning a zero vector the length of tvec. Similar to \code{K3vectorized}, \code{K4vectorized} is essential for discrepancy calculations, which should not be performed without an implementation of this function.}

\item{ineq_vectorized}{A function representing the inequality constraints for the domain of the CGF. The constraints defined in this function should be non-positive for valid values of tvec. If a CGF does not require any constraints, it defaults to returning an empty vector.}
}
\value{
An object of class 'CGF'.
}
\description{
This function generates a CGF object for univariate distributions, with vectorization to handle iid data.
All functions must take two arguments: tvec (vector for independent variable values)
and parameter_vector (vector of underlying parameters).
}
\examples{
\dontrun{
# Define the vectorized functions of the CGF object for a gamma distribution
vectorized_k <- function(tvec, parameter_vector){
  shape <- parameter_vector[1]
  rate <- parameter_vector[2]
  -shape * log1p(-tvec / rate)
}
vectorized_k1 <- function(tvec, parameter_vector){
  shape <- parameter_vector[1]
  rate <- parameter_vector[2]
  shape / (rate - tvec)
}
vectorized_k2 <- function(tvec, parameter_vector){
  shape <- parameter_vector[1]
  rate <- parameter_vector[2]
  shape / (rate - tvec)^2
}
vectorized_k3 <- function(tvec, parameter_vector){
  shape <- parameter_vector[1]
  rate <- parameter_vector[2]
  2 * shape / (rate - tvec)^3
}
vectorized_k4 <- function(tvec, parameter_vector){
  shape <- parameter_vector[1]
  rate <- parameter_vector[2]
  6 * shape / (rate - tvec)^4
}
# ineq_constraint is such that: tvec < rate
# The value of the next function is constrained to be non-positive: tvec - rate < 0
vectorized_ineq_constrain_fn <- function(tvec, parameter_vector){
  rate <- parameter_vector[2]
  tvec - rate
}

# Create the CGF object for the gamma distribution
my_gamma_cgf <- createCustomCGF(Kvectorized = vectorized_k, K1vectorized = vectorized_k1, 
                                K2vectorized = vectorized_k2, K3vectorized = vectorized_k3,
                                K4vectorized = vectorized_k4, ineq_vectorized = vectorized_ineq_constrain_fn)

# Example usage: Evaluate the first derivative at tvec = 0, parameters shape = 2, rate = 0.3
# Compare this result to the main CGF object GammaCGF implementation 
my_gamma_cgf$K1(0, c(2, 0.3)) == GammaCGF$K1(0, c(2, 0.3))
}
}
